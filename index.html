<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Telegram Word Cloud Generator</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.23.5/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            margin: 0;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen', 'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue', sans-serif;
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState } = React;

        const Upload = ({ size = 24 }) => (
            <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                <polyline points="17 8 12 3 7 8"></polyline>
                <line x1="12" y1="3" x2="12" y2="15"></line>
            </svg>
        );

        const MessageSquare = ({ size = 24 }) => (
            <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                <path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"></path>
            </svg>
        );

        const Search = ({ size = 24 }) => (
            <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                <circle cx="11" cy="11" r="8"></circle>
                <path d="m21 21-4.35-4.35"></path>
            </svg>
        );

        const Edit = ({ size = 24 }) => (
            <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                <path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"></path>
                <path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"></path>
            </svg>
        );

        const Sparkles = ({ size = 24 }) => (
            <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                <path d="m12 3-1.912 5.813a2 2 0 0 1-1.275 1.275L3 12l5.813 1.912a2 2 0 0 1 1.275 1.275L12 21l1.912-5.813a2 2 0 0 1 1.275-1.275L21 12l-5.813-1.912a2 2 0 0 1-1.275-1.275L12 3Z"></path>
                <path d="M5 3v4"></path>
                <path d="M19 17v4"></path>
                <path d="M3 5h4"></path>
                <path d="M17 19h4"></path>
            </svg>
        );

        const TelegramWordCloud = () => {
            const [userData, setUserData] = useState([]);
            const [selectedUser, setSelectedUser] = useState(null);
            const [processing, setProcessing] = useState(false);
            const [searchTerm, setSearchTerm] = useState('');
            const [searchResult, setSearchResult] = useState(null);

            const stopWords = new Set([
                'the', 'be', 'to', 'of', 'and', 'a', 'in', 'that', 'have', 'it', 'for', 'not', 'on', 'with', 'he', 'as', 'you', 'do', 'at', 'this', 'but', 'his', 'by', 'from', 'they', 'we', 'say', 'her', 'she', 'or', 'an', 'will', 'my', 'one', 'all', 'would', 'there', 'their', 'what', 'so', 'up', 'out', 'if', 'about', 'who', 'get', 'which', 'go', 'me', 'when', 'make', 'can', 'like', 'time', 'no', 'just', 'him', 'know', 'take', 'people', 'into', 'year', 'your', 'good', 'some', 'could', 'them', 'see', 'other', 'than', 'then', 'now', 'look', 'only', 'come', 'its', 'over', 'think', 'also', 'back', 'after', 'use', 'two', 'how', 'our', 'work', 'first', 'well', 'way', 'even', 'new', 'want', 'because', 'any', 'these', 'give', 'day', 'most', 'us', 'is', 'was', 'are', 'been', 'has', 'had', 'were', 'said', 'did', 'having', 'may', 'am', 'yeah', 'oh', 'lol', 'haha', 'lmao'
            ]);

            const urlWords = new Set([
                'www', 'http', 'https', 'com', 'org', 'net', 'io', 'co', 'uk', 'edu', 'gov',
                'instagram', 'youtube', 'twitter', 'facebook', 'tiktok', 'reddit', 'linkedin',
                'gmail', 'yahoo', 'outlook', 'app', 'html', 'htm', 'php', 'asp',
                'utm', 'campaign', 'medium', 'source', 'content'
            ]);

            const isValidWord = (word) => {
                if (!word || word.length <= 2) return false;
                if (stopWords.has(word)) return false;
                if (urlWords.has(word)) return false;
                if (word.includes('://')) return false;
                if (word.startsWith('www')) return false;
                if (/\.(com|org|net|io|co|edu|gov|uk)/.test(word)) return false;
                if (/^https?/.test(word)) return false;
                if (/^\d+$/.test(word)) return false;
                // Filter out UTM parameters and URL query strings
                if (/^utm_/.test(word)) return false;
                if (word.includes('_') && /utm|campaign|fbclid|gclid/.test(word)) return false;
                return true;
            };

            const normalizeText = (text) => {
                return text.toLowerCase()
                    .replace(/[^\w\s']/g, ' ')
                    .replace(/\s+/g, ' ')
                    .trim();
            };

            const generateInsights = (userObj) => {
                const insights = [];
                const totalWords = userObj.wordCounts.size;
                const totalMessages = userObj.messages.length;
                const totalWordCount = Array.from(userObj.wordCounts.values()).reduce((a, b) => a + b, 0);
                const avgWordsPerMsg = totalMessages > 0 ? (totalWordCount / totalMessages).toFixed(1) : 0;
                
                const topWords = Array.from(userObj.wordCounts.entries())
                    .sort((a, b) => b[1] - a[1])
                    .slice(0, 5)
                    .map(([word]) => word);
                
                if (avgWordsPerMsg > 20) {
                    insights.push("Tends to write long, detailed messages");
                } else if (avgWordsPerMsg < 5) {
                    insights.push("Prefers short, concise messages");
                } else {
                    insights.push("Writes moderately-sized messages");
                }
                
                const emotionalWords = ['love', 'hate', 'amazing', 'terrible', 'great', 'awesome', 'horrible', 'fantastic'];
                const hasEmotionalWords = topWords.some(word => emotionalWords.includes(word));
                if (hasEmotionalWords) {
                    insights.push("Expressive and uses emotional language");
                }
                
                const questionWords = ['why', 'what', 'how', 'when', 'where', 'who'];
                const asksQuestions = Array.from(userObj.wordCounts.keys()).some(word => questionWords.includes(word));
                if (asksQuestions) {
                    insights.push("Frequently asks questions");
                }
                
                const diversityRatio = totalWords / totalMessages;
                if (diversityRatio > 15) {
                    insights.push("Uses diverse vocabulary");
                } else if (diversityRatio < 5) {
                    insights.push("Uses repetitive vocabulary");
                }
                
                insights.push(`Most discussed: ${topWords.slice(0, 3).join(', ')}`);
                
                return insights;
            };

            const detectHyperbole = (userObj) => {
                const wordCounts = userObj.wordCounts;

                const extremeWords = {
                    'garbage': wordCounts.get('garbage') || 0,
                    'amazing': wordCounts.get('amazing') || 0,
                    'incredible': wordCounts.get('incredible') || 0,
                    'literally': wordCounts.get('literally') || 0,
                    'absolutely': wordCounts.get('absolutely') || 0,
                    'completely': wordCounts.get('completely') || 0,
                    'totally': wordCounts.get('totally') || 0,
                    'never': wordCounts.get('never') || 0,
                    'always': wordCounts.get('always') || 0,
                    'everything': wordCounts.get('everything') || 0,
                    'nothing': wordCounts.get('nothing') || 0,
                    'everyone': wordCounts.get('everyone') || 0,
                    'nobody': wordCounts.get('nobody') || 0,
                    'forever': wordCounts.get('forever') || 0,
                    'impossible': wordCounts.get('impossible') || 0,
                    'insane': wordCounts.get('insane') || 0,
                    'crazy': wordCounts.get('crazy') || 0,
                    'dying': wordCounts.get('dying') || 0,
                    'dead': wordCounts.get('dead') || 0,
                    'million': wordCounts.get('million') || 0,
                    'billion': wordCounts.get('billion') || 0,
                    'infinite': wordCounts.get('infinite') || 0,
                    'worst': wordCounts.get('worst') || 0,
                    'best': wordCounts.get('best') || 0
                };

                // Debug logging
                console.log('Hyperbole word counts:', extremeWords);

                let allCapsCount = 0;
                userObj.messages.forEach(msg => {
                    if (shouldExcludeMessage(msg)) return;
                    if (msg.length > 3 && msg === msg.toUpperCase() && /[A-Z]/.test(msg)) {
                        allCapsCount++;
                    }
                });

                let excessivePunctuation = 0;
                userObj.messages.forEach(msg => {
                    if (shouldExcludeMessage(msg)) return;
                    if (/[!?]{2,}/.test(msg)) {
                        excessivePunctuation++;
                    }
                });

                // Priority words that should always appear at the top if they have counts
                const priorityWords = ['garbage', 'amazing', 'incredible'];

                // Separate priority words from other words
                const priorityEntries = [];
                const otherEntries = [];

                Object.entries(extremeWords).forEach(([word, count]) => {
                    if (count > 0) {
                        if (priorityWords.includes(word)) {
                            priorityEntries.push([word, count]);
                        } else {
                            otherEntries.push([word, count]);
                        }
                    }
                });

                // Sort priority words by count (garbage first if equal counts)
                priorityEntries.sort((a, b) => {
                    if (b[1] !== a[1]) return b[1] - a[1];
                    return priorityWords.indexOf(a[0]) - priorityWords.indexOf(b[0]);
                });

                // Sort other words by count
                otherEntries.sort((a, b) => b[1] - a[1]);

                // Combine: priority words first, then top 7 other words (to make 10 total)
                const remainingSlots = Math.max(0, 10 - priorityEntries.length);
                const topHyperbolic = [...priorityEntries, ...otherEntries.slice(0, remainingSlots)];

                console.log('Top hyperbolic words:', topHyperbolic);

                return {
                    words: topHyperbolic,
                    allCapsCount,
                    excessivePunctuation,
                    totalHyperbolic: topHyperbolic.reduce((sum, [, count]) => sum + count, 0)
                };
            };

            const shouldExcludeMessage = (text) => {
                const trimmed = text.trim();
                // Exclude mentions (messages starting with @username)
                if (/^@\w+/.test(trimmed)) return true;
                // Exclude "posted a photo" messages
                if (/posted a photo/i.test(trimmed)) return true;
                // Exclude messages that are primarily UTM parameters or URL fragments
                if (/utm_\w+/.test(trimmed)) return true;
                return false;
            };

            const extractSentences = (messages) => {
                const sentences = {};

                messages.forEach(text => {
                    if (shouldExcludeMessage(text)) return;

                    const sents = text.split(/[.!?]+/).map(s => s.trim()).filter(s => s.length > 10);

                    sents.forEach(sent => {
                        const normalized = normalizeText(sent);
                        const words = normalized.split(/\s+/);

                        if (words.length >= 4 && words.length <= 12) {
                            sentences[normalized] = (sentences[normalized] || 0) + 1;
                        }
                    });
                });

                return Object.entries(sentences)
                    .filter(([, count]) => count >= 2)
                    .sort((a, b) => b[1] - a[1])
                    .slice(0, 15);
            };

            const extractPhrases = (messages) => {
                const phrases = {};

                messages.forEach(text => {
                    if (shouldExcludeMessage(text)) return;

                    const normalized = normalizeText(text);
                    const words = normalized.split(/\s+/).filter(w => w.length > 2);

                    for (let i = 0; i < words.length - 1; i++) {
                        if (isValidWord(words[i]) && isValidWord(words[i + 1])) {
                            const phrase = `${words[i]} ${words[i + 1]}`;
                            phrases[phrase] = (phrases[phrase] || 0) + 1;
                        }
                    }

                    for (let i = 0; i < words.length - 2; i++) {
                        if (isValidWord(words[i]) && isValidWord(words[i + 1]) && isValidWord(words[i + 2])) {
                            const phrase = `${words[i]} ${words[i + 1]} ${words[i + 2]}`;
                            phrases[phrase] = (phrases[phrase] || 0) + 1;
                        }
                    }
                });

                return Object.entries(phrases)
                    .filter(([, count]) => count >= 3)
                    .sort((a, b) => b[1] - a[1])
                    .slice(0, 20);
            };

            const processFile = async (event) => {
                const file = event.target.files[0];
                console.log('File selected:', file);
                if (!file) {
                    console.log('No file selected');
                    return;
                }

                setProcessing(true);
                console.log('Starting to process file...');
                
                try {
                    const text = await file.text();
                    console.log('File loaded, size:', text.length, 'characters');
                    const data = JSON.parse(text);
                    console.log('JSON parsed successfully');
                    
                    if (!data.messages || !Array.isArray(data.messages)) {
                        throw new Error('Invalid Telegram export format');
                    }
                    
                    console.log('Found', data.messages.length, 'messages');
                    
                    const userMap = new Map();
                    
                    data.messages.forEach(msg => {
                        if (msg.type === 'message' && msg.text && msg.from) {
                            const userName = String(msg.from);

                            if (!userMap.has(userName)) {
                                userMap.set(userName, {
                                    wordCounts: new Map(),
                                    messages: [],
                                    rawMessages: [],
                                    editedCount: 0
                                });
                            }

                            const userObj = userMap.get(userName);

                            if (msg.edited) {
                                userObj.editedCount++;
                            }

                            let textContent = '';
                            if (typeof msg.text === 'string') {
                                textContent = msg.text;
                            } else if (Array.isArray(msg.text)) {
                                textContent = msg.text.map(t => {
                                    if (typeof t === 'string') return t;
                                    if (t && typeof t === 'object' && t.text) return t.text;
                                    return '';
                                }).join(' ');
                            }

                            if (textContent.trim() && !shouldExcludeMessage(textContent)) {
                                userObj.messages.push(textContent);
                                userObj.rawMessages.push(textContent.toLowerCase());

                                const normalized = normalizeText(textContent);
                                const words = normalized.split(/\s+/).filter(w => isValidWord(w));

                                words.forEach(word => {
                                    userObj.wordCounts.set(word, (userObj.wordCounts.get(word) || 0) + 1);
                                });
                            }
                        }
                    });
                    
                    const processedUsers = Array.from(userMap.entries()).map(([userName, userObj]) => {
                        const wordArray = Array.from(userObj.wordCounts.entries());
                        const totalWords = wordArray.reduce((sum, [, count]) => sum + count, 0);
                        const topWords = wordArray.sort((a, b) => b[1] - a[1]).slice(0, 100);
                        const phrases = extractPhrases(userObj.messages);
                        const sentences = extractSentences(userObj.messages);
                        const insights = generateInsights(userObj);
                        const hyperbole = detectHyperbole(userObj);
                        
                        return {
                            name: userName,
                            words: topWords,
                            totalWords: totalWords,
                            uniqueWords: wordArray.length,
                            phrases: phrases,
                            sentences: sentences,
                            insights: insights,
                            hyperbole: hyperbole,
                            editedCount: userObj.editedCount,
                            messageCount: userObj.messages.length,
                            rawMessages: userObj.rawMessages,
                            wordCounts: userObj.wordCounts
                        };
                    });
                    
                    console.log('Processed', processedUsers.length, 'users');
                    
                    setUserData(processedUsers);
                    if (processedUsers.length > 0) {
                        setSelectedUser(0);
                    }
                    
                    console.log('Processing complete!');
                    
                } catch (error) {
                    console.error('Processing error:', error);
                    alert('Error processing file: ' + error.message);
                }
                
                setProcessing(false);
            };

            const handleSearch = () => {
                if (!searchTerm || selectedUser === null) return;
                
                const user = userData[selectedUser];
                const searchLower = searchTerm.toLowerCase();
                
                let count = 0;
                user.rawMessages.forEach(msg => {
                    const occurrences = (msg.match(new RegExp(searchLower.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'g')) || []).length;
                    count += occurrences;
                });
                
                const wordCount = user.wordCounts.get(normalizeText(searchTerm)) || 0;
                
                setSearchResult({
                    term: searchTerm,
                    count: Math.max(count, wordCount)
                });
            };

            const generateWordCloud = (words) => {
                if (!words || words.length === 0) return [];

                const positions = [];
                const maxFreq = words[0][1];
                const minFreq = words[words.length - 1][1];

                // Sort words by frequency
                const sortedWords = [...words].sort((a, b) => b[1] - a[1]);

                // Limit to 60 words
                const displayWords = sortedWords.slice(0, 60);

                // Flexible grid layout - words arranged in staggered rows
                const wordsPerRow = [6, 8, 10, 8, 10, 8, 6, 4]; // Varying row lengths for organic look
                let wordIndex = 0;
                let currentY = 8;

                wordsPerRow.forEach((numWords, rowIdx) => {
                    const wordsInThisRow = Math.min(numWords, displayWords.length - wordIndex);
                    if (wordsInThisRow <= 0) return;

                    for (let i = 0; i < wordsInThisRow; i++) {
                        if (wordIndex >= displayWords.length) break;

                        const [word, freq] = displayWords[wordIndex];
                        const normalizedSize = minFreq === maxFreq ? 1 : (freq - minFreq) / (maxFreq - minFreq);
                        const fontSize = 18 + normalizedSize * 44;
                        const opacity = 0.8 + normalizedSize * 0.2;
                        const hue = (wordIndex * 137.5) % 360;

                        // Calculate X position with even spacing and slight randomization
                        const rowWidth = 84; // Total width to use
                        const startX = (100 - rowWidth) / 2; // Center the row
                        const spacing = rowWidth / (wordsInThisRow + 1);
                        const x = startX + spacing * (i + 1) + (Math.random() - 0.5) * 2;

                        // Y position with spacing based on font size
                        const y = currentY + (Math.random() - 0.5) * 1;

                        positions.push({
                            word,
                            freq,
                            fontSize,
                            opacity,
                            color: `hsl(${hue}, 70%, ${50 + normalizedSize * 10}%)`,
                            left: `${x}%`,
                            top: `${y}%`
                        });

                        wordIndex++;
                    }

                    // Move to next row with dynamic spacing
                    currentY += 10 + Math.random() * 2;
                });

                return positions;
            };

            const currentUser = selectedUser !== null ? userData[selectedUser] : null;

            return (
                <div className="min-h-screen bg-gradient-to-br from-gray-900 via-blue-900 to-purple-900 text-white p-8">
                    <div className="max-w-7xl mx-auto">
                        <div className="text-center mb-12">
                            <h1 className="text-5xl font-bold mb-4 bg-gradient-to-r from-blue-400 to-purple-400 bg-clip-text text-transparent">
                                Telegram Word Cloud Generator
                            </h1>
                            <p className="text-gray-300 text-lg">Visualize your chat patterns beautifully</p>
                        </div>
                        
                        <div className="bg-gray-800/50 backdrop-blur-sm rounded-2xl p-8 mb-8 border border-gray-700 shadow-2xl">
                            <label className="flex items-center justify-center gap-4 p-12 border-2 border-dashed border-blue-500/50 rounded-xl cursor-pointer hover:border-blue-400 hover:bg-blue-500/5 transition-all">
                                <Upload size={32} />
                                <span className="text-xl">
                                    {processing ? 'Processing your chat...' : userData.length > 0 ? 'Upload Different Chat (JSON)' : 'Upload Telegram Chat Export (JSON)'}
                                </span>
                                <input
                                    type="file"
                                    accept=".json"
                                    onChange={processFile}
                                    className="hidden"
                                    disabled={processing}
                                />
                            </label>
                            {userData.length > 0 && (
                                <p className="text-center text-gray-400 text-sm mt-4">
                                    Upload a new file to replace the current data
                                </p>
                            )}
                        </div>

                        {userData.length > 0 && (
                            <>
                                <div className="bg-gray-800/50 backdrop-blur-sm rounded-2xl p-8 mb-8 border border-gray-700 shadow-2xl">
                                    <h2 className="text-3xl font-bold mb-6 flex items-center gap-3">
                                        <MessageSquare />
                                        Select User ({userData.length} users)
                                    </h2>
                                    <div className="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-4 xl:grid-cols-5 gap-4">
                                        {userData.map((user, idx) => (
                                            <button
                                                key={idx}
                                                onClick={() => {
                                                    setSelectedUser(idx);
                                                    setSearchResult(null);
                                                    setSearchTerm('');
                                                }}
                                                className={`p-5 rounded-xl transition-all transform hover:scale-105 ${
                                                    selectedUser === idx
                                                        ? 'bg-gradient-to-br from-blue-500 to-purple-500 shadow-lg shadow-blue-500/50'
                                                        : 'bg-gray-700/50 hover:bg-gray-700'
                                                }`}
                                            >
                                                <div className="font-bold text-lg truncate mb-2" title={user.name}>
                                                    {user.name}
                                                </div>
                                                <div className="text-sm text-gray-300 space-y-1">
                                                    <div>{user.totalWords.toLocaleString()} words</div>
                                                    <div className="text-xs text-gray-400">{user.uniqueWords.toLocaleString()} unique</div>
                                                </div>
                                                {user.editedCount > 0 && (
                                                    <div className="text-xs text-yellow-300 flex items-center gap-1 mt-2 justify-center bg-yellow-500/20 rounded-full py-1 px-2">
                                                        <Edit size={12} />
                                                        {user.editedCount} edited
                                                    </div>
                                                )}
                                            </button>
                                        ))}
                                    </div>
                                </div>

                                {currentUser && (
                                    <>
                                        <div className="bg-gray-800/50 backdrop-blur-sm rounded-2xl p-8 mb-8 border border-gray-700 shadow-2xl">
                                            <h3 className="text-2xl font-bold mb-6 flex items-center gap-3 text-purple-300">
                                                <Sparkles />
                                                Insights for {currentUser.name}
                                            </h3>
                                            <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
                                                {currentUser.insights.map((insight, idx) => (
                                                    <div key={idx} className="bg-gradient-to-r from-purple-900/30 to-pink-900/30 rounded-xl p-4 border border-purple-500/20">
                                                        <p className="text-gray-200">• {insight}</p>
                                                    </div>
                                                ))}
                                                <div className="bg-gradient-to-r from-blue-900/30 to-cyan-900/30 rounded-xl p-4 border border-blue-500/20">
                                                    <p className="text-gray-200">• Sent {currentUser.messageCount.toLocaleString()} messages</p>
                                                </div>
                                                {currentUser.editedCount > 0 && (
                                                    <div className="bg-gradient-to-r from-yellow-900/30 to-orange-900/30 rounded-xl p-4 border border-yellow-500/20">
                                                        <p className="text-gray-200">• Edited {currentUser.editedCount} messages ({((currentUser.editedCount / currentUser.messageCount) * 100).toFixed(1)}%)</p>
                                                    </div>
                                                )}
                                            </div>
                                        </div>

                                        {currentUser.hyperbole.totalHyperbolic > 0 && (
                                            <div className="bg-gray-800/50 backdrop-blur-sm rounded-2xl p-8 mb-8 border border-gray-700 shadow-2xl">
                                                <h3 className="text-2xl font-bold mb-6 text-orange-300">Hyperbole Detector 🎭</h3>
                                                <div className="space-y-4">
                                                    <div className="bg-gradient-to-r from-orange-900/30 to-red-900/30 rounded-xl p-6 border border-orange-500/20">
                                                        <p className="text-xl font-bold text-orange-300 mb-4">
                                                            Dramatic Language Score: {currentUser.hyperbole.totalHyperbolic} instances
                                                        </p>
                                                        <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-3">
                                                            {currentUser.hyperbole.words.map(([word, count], idx) => (
                                                                <div key={idx} className="flex items-center justify-between bg-gray-700/50 rounded-lg p-3">
                                                                    <span className="text-gray-200 capitalize font-semibold">"{word}"</span>
                                                                    <span className="text-orange-400 font-bold">{count}×</span>
                                                                </div>
                                                            ))}
                                                        </div>
                                                    </div>

                                                    <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                                                        {currentUser.hyperbole.allCapsCount > 0 && (
                                                            <div className="bg-gradient-to-r from-red-900/30 to-pink-900/30 rounded-xl p-4 border border-red-500/20">
                                                                <p className="text-gray-200">
                                                                    📢 Sent <span className="font-bold text-red-300">{currentUser.hyperbole.allCapsCount}</span> ALL CAPS messages
                                                                </p>
                                                            </div>
                                                        )}

                                                        {currentUser.hyperbole.excessivePunctuation > 0 && (
                                                            <div className="bg-gradient-to-r from-yellow-900/30 to-orange-900/30 rounded-xl p-4 border border-yellow-500/20">
                                                                <p className="text-gray-200">
                                                                    ‼️ Used excessive punctuation in <span className="font-bold text-yellow-300">{currentUser.hyperbole.excessivePunctuation}</span> messages (!!! or ???)
                                                                </p>
                                                            </div>
                                                        )}
                                                    </div>
                                                </div>
                                            </div>
                                        )}

                                        <div className="bg-gray-800/50 backdrop-blur-sm rounded-2xl p-8 mb-8 border border-gray-700 shadow-2xl">
                                            <h3 className="text-2xl font-bold mb-6 flex items-center gap-3 text-blue-300">
                                                <Search />
                                                Search Word or Phrase
                                            </h3>
                                            <div className="flex gap-4">
                                                <input
                                                    type="text"
                                                    value={searchTerm}
                                                    onChange={(e) => setSearchTerm(e.target.value)}
                                                    onKeyPress={(e) => e.key === 'Enter' && handleSearch()}
                                                    placeholder="Enter word or phrase..."
                                                    className="flex-1 bg-gray-700 text-white px-6 py-3 rounded-xl border border-gray-600 focus:border-blue-500 focus:outline-none"
                                                />
                                                <button
                                                    onClick={handleSearch}
                                                    className="bg-gradient-to-r from-blue-500 to-purple-500 hover:from-blue-600 hover:to-purple-600 px-8 py-3 rounded-xl transition-all font-bold"
                                                >
                                                    Search
                                                </button>
                                            </div>
                                            {searchResult && (
                                                <div className="mt-4 bg-gradient-to-r from-green-900/30 to-emerald-900/30 rounded-xl p-6 border border-green-500/20">
                                                    <p className="text-2xl font-bold text-green-300">
                                                        "{searchResult.term}" appears {searchResult.count} time{searchResult.count !== 1 ? 's' : ''}
                                                    </p>
                                                </div>
                                            )}
                                        </div>

                                        {currentUser.sentences.length > 0 && (
                                            <div className="bg-gray-800/50 backdrop-blur-sm rounded-2xl p-8 mb-8 border border-gray-700 shadow-2xl">
                                                <h3 className="text-2xl font-bold mb-6 text-purple-300">Most Repeated Sentences</h3>
                                                <div className="grid grid-cols-1 lg:grid-cols-2 gap-3">
                                                    {currentUser.sentences.map(([sentence, count], idx) => (
                                                        <div key={idx} className="flex items-start gap-4 bg-gradient-to-r from-purple-900/30 to-blue-900/30 rounded-xl p-4 border border-purple-500/20">
                                                            <div className="text-2xl font-bold text-purple-400 min-w-[2rem]">
                                                                {idx + 1}
                                                            </div>
                                                            <div className="flex-1">
                                                                <div className="text-lg italic text-gray-200">"{sentence}"</div>
                                                            </div>
                                                            <div className="text-xl font-bold text-purple-300 bg-purple-500/20 px-3 py-1 rounded-full">
                                                                {count}×
                                                            </div>
                                                        </div>
                                                    ))}
                                                </div>
                                            </div>
                                        )}

                                        <div className="bg-gray-800/50 backdrop-blur-sm rounded-2xl p-8 mb-8 border border-gray-700 shadow-2xl">
                                            <h3 className="text-2xl font-bold mb-6 text-blue-300">Most Common Phrases</h3>
                                            {currentUser.phrases.length > 0 ? (
                                                <div className="grid grid-cols-1 md:grid-cols-2 gap-3">
                                                    {currentUser.phrases.map(([phrase, count], idx) => (
                                                        <div key={idx} className="flex items-center gap-3 bg-gradient-to-r from-blue-900/30 to-cyan-900/30 rounded-xl p-4 border border-blue-500/20">
                                                            <div className="text-xl font-bold text-blue-400 min-w-[2rem]">
                                                                {idx + 1}
                                                            </div>
                                                            <div className="flex-1">
                                                                <div className="font-semibold text-gray-200">"{phrase}"</div>
                                                            </div>
                                                            <div className="text-lg font-bold text-blue-300 bg-blue-500/20 px-3 py-1 rounded-full">
                                                                {count}×
                                                            </div>
                                                        </div>
                                                    ))}
                                                </div>
                                            ) : (
                                                <p className="text-gray-400">No repeated phrases found</p>
                                            )}
                                        </div>

                                        <div className="bg-gray-800/50 backdrop-blur-sm rounded-2xl p-8 border border-gray-700 shadow-2xl">
                                            <div className="flex justify-between items-center mb-8">
                                                <h2 className="text-3xl font-bold bg-gradient-to-r from-blue-400 to-purple-400 bg-clip-text text-transparent">
                                                    Word Cloud - {currentUser.name}
                                                </h2>
                                            </div>
                                            
                                            <div className="bg-gradient-to-br from-gray-900 to-gray-800 rounded-2xl p-12 min-h-[600px] relative overflow-hidden border border-gray-700">
                                                {currentUser.words.length > 0 ? (
                                                    <div className="relative w-full h-full min-h-[600px]">
                                                        {generateWordCloud(currentUser.words).map((item, idx) => (
                                                            <div
                                                                key={idx}
                                                                style={{
                                                                    position: 'absolute',
                                                                    left: item.left,
                                                                    top: item.top,
                                                                    transform: 'translate(-50%, -50%)',
                                                                    fontSize: `${item.fontSize}px`,
                                                                    color: item.color,
                                                                    opacity: item.opacity,
                                                                    fontWeight: 'bold',
                                                                    transition: 'all 0.3s ease',
                                                                    textShadow: '0 2px 4px rgba(0,0,0,0.5)',
                                                                    whiteSpace: 'nowrap'
                                                                }}
                                                                className="hover:scale-110 cursor-default hover:opacity-100"
                                                                title={`${item.word}: ${item.freq} times`}
                                                            >
                                                                {item.word}
                                                            </div>
                                                        ))}
                                                    </div>
                                                ) : (
                                                    <div className="text-gray-400 text-center flex items-center justify-center h-full">
                                                        <div>
                                                            <p className="text-xl">No valid words found</p>
                                                            <p className="text-sm mt-2">Only media or short messages</p>
                                                        </div>
                                                    </div>
                                                )}
                                            </div>

                                            <div className="mt-6 text-center text-gray-400">
                                                {currentUser.words.length > 0 && (
                                                    <>Top {currentUser.words.length} words from {currentUser.totalWords.toLocaleString()} total</>
                                                )}
                                            </div>
                                        </div>
                                    </>
                                )}
                            </>
                        )}

                        {userData.length === 0 && !processing && (
                            <div className="text-center text-gray-300 py-20">
                                <MessageSquare size={64} className="mx-auto mb-6 text-blue-400 opacity-50" />
                                <p className="text-2xl mb-3">Upload your Telegram chat to begin</p>
                                <p className="text-gray-400">Desktop: Chat menu → Export chat history → JSON format</p>
                            </div>
                        )}
                    </div>
                </div>
            );
        };

        ReactDOM.render(<TelegramWordCloud />, document.getElementById('root'));
    </script>
</body>
</html>